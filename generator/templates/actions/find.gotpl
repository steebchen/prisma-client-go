{{- /*gotype:github.com/prisma/prisma-client-go/generator.Root*/ -}}

{{ range $model := $.DMMF.Datamodel.Models }}
	{{ range $field := $model.RelationFieldsPlusOne }}
		{{ range $v := $.DMMF.Variations }}
			{{ $name := $model.Name.GoLowerCase }}
			{{ $ns := (print $name "Actions") }}

			{{ $result := (print $name "Find" $v.Name) }}
			{{ $updateResult := (print $name "Update" $v.Name) }}
			{{ $deleteResult := (print $name "Delete" $v.Name) }}

			{{ $relationName := $model.Name.GoCase }}

			{{ $orderByParams := (print "i" $model.Name.GoCase "OrderByParams") }}

			{{ if ne $field.Name "" }}
				{{ $result = (print $name "To" $field.Name.GoCase "Find" $v.Name) }}
				{{ $updateResult = (print $name "To" $field.Name.GoCase "Update" $v.Name) }}
				{{ $deleteResult = (print $name "To" $field.Name.GoCase "Delete" $v.Name) }}
				{{ $relationName = $field.Type.GoCase }}
				{{ $orderByParams = (print "i" $field.Type.GoCase "OrderByParams") }}
			{{ end }}

			type {{ $result }} struct {
				query builder.Query
			}

			func (r {{ $result }}) getQuery() builder.Query {
				return r.query
			}

			func (r {{ $result }}) ExtractQuery() builder.Query {
				return r.query
			}

			func (r {{ $result }}) with() {}
			func (r {{ $result }}) {{ $model.Name.GoLowerCase }}Model() {}
			func (r {{ $result }}) {{ $model.Name.GoLowerCase }}Relation() {}

			{{ if eq $field.Name "" }}
				{{/* only allow equals & unique params for FindUnique */}}
				{{- if eq $v.Name "One" }}
					// deprecated: use FindUnique instead
				{{- end }}
				func (r {{ $ns }}) Find{{ $v.Name }}(
					params {{ if $v.List }}...{{ end }}i{{ $model.Name.GoCase }}{{ if not $v.List }}Equals{{ end }}Params{{ if not $v.List }}Unique{{ end }},
				) {{ $result }} {
					var v {{ $result }}
					v.query = builder.NewQuery()
					v.query.Engine = r.client

					v.query.Operation = "query"
					{{ if eq $v.Name "First" }}
						v.query.Method = "findFirst"
					{{ else }}
						v.query.Method = "find{{ $v.ActualName }}"
					{{ end }}
					v.query.Model = "{{ $model.Name.String }}"
					v.query.Outputs = {{ $name }}Output

					{{ if $v.List }}
						{{/* TODO create a function for this type of builder.Field colletion, also used in query.gotpl */}}
						var where []builder.Field
						for _, q := range params {
							if query := q.getQuery(); query.Operation != "" {
								v.query.Outputs = append(v.query.Outputs, builder.Output{
									Name:    query.Method,
									Inputs:  query.Inputs,
									Outputs: query.Outputs,
								})
							} else {
								where = append(where, q.field())
							}
						}

						if len(where) > 0 {
							v.query.Inputs = append(v.query.Inputs, builder.Input{
								Name:   "where",
								Fields: where,
							})
						}
					{{ else }}
						{{/* transform this document because the signature of FindUnique is different than FindMany */}}
						v.query.Inputs = append(v.query.Inputs, builder.Input{
							Name:   "where",
							Fields: builder.TransformEquals([]builder.Field{params.field()}),
						})
					{{ end }}

					return v
				}
			{{ end }}

			func (r {{ $result }}) With(params ...i{{ $relationName }}RelationWith) {{ $result }} {
				for _, q := range params {
					query := q.getQuery()
					r.query.Outputs = append(r.query.Outputs, builder.Output{
						Name:    query.Method,
						Inputs:  query.Inputs,
						Outputs: query.Outputs,
					})
				}

				return r
			}

			{{ if $v.List }}
				func (r {{ $result }}) OrderBy(params ...{{ $orderByParams }}) {{ $result }} {
					var fields []builder.Field

					for _, param := range params {
						direction, _ := param.field().Value.(types.Direction)

						fields = append(fields, builder.Field{
							Name: param.field().Name,
							Value: direction,
						})
					}

					r.query.Inputs = append(r.query.Inputs, builder.Input{
						Name:  "orderBy",
						Fields: fields,
					})

					return r
				}

				func (r {{ $result }}) Skip(count int) {{ $result }} {
					r.query.Inputs = append(r.query.Inputs, builder.Input{
						Name:  "skip",
						Value: count,
					})
					return r
				}

				func (r {{ $result }}) Take(count int) {{ $result }} {
					r.query.Inputs = append(r.query.Inputs, builder.Input{
						Name:  "take",
						Value: count,
					})
					return r
				}

				func (r {{ $result }}) Cursor(cursor i{{ $model.Name.GoCase }}CursorParams) {{ $result }} {
					r.query.Inputs = append(r.query.Inputs, builder.Input{
						Name:  "cursor",
						Fields: []builder.Field{cursor.field()},
					})
					return r
				}
			{{ end }}

			func (r {{ $result }}) Exec(ctx context.Context) (
				{{ if $v.ReturnList }}[]{{ end }}{{ $model.Name.GoCase }}Model,
				error,
			) {
				var v *{{ if $v.ReturnList }}[]{{ end }}{{ $model.Name.GoCase }}Model
				if err := r.query.Exec(ctx, &v); err != nil {
					return {{ if $v.ReturnList }}[]{{ end }}{{ $model.Name.GoCase }}Model{}, err
				}
				{{ if not $v.ReturnList }}
					if v == nil {
						return {{ if $v.ReturnList }}[]{{ end }}{{ $model.Name.GoCase }}Model{}, ErrNotFound
					}
				{{ end }}
				return *v, nil
			}

			{{ if ne $v.Name "First" }}
				{{ $outputName := $name }}
				{{ $returnType := print $model.Name.GoCase "Model" }}
				{{ if $v.List }}
					{{ $returnType = "int" }}
					{{ $outputName = "count" }}
				{{ end }}

				{{/* UPDATE */}}

				{{ $setParams := (print "i" $model.Name.GoCase "SetParams") }}

				func (r {{ $result }}) Update(params ...{{ $setParams }}) {{ $updateResult }} {
					r.query.Operation = "mutation"
					r.query.Method = "update{{ $v.ActualName }}"
					r.query.Model = "{{ $model.Name.GoCase }}"
					r.query.Outputs = {{ $outputName }}Output

					var v {{ $updateResult }}
					v.query = r.query
					var fields []builder.Field
					for _, q := range params {
						{{/* TODO consider upcoming non-set methods */}}
						field := q.field()
						{{/* if scalar, wrap in 'set' */}}
						if field.Value != nil {
							v := field.Value
							field.Fields = []builder.Field{
								{
									Name: "set",
									Value: v,
								},
							}

							field.Value = nil
						}

						fields = append(fields, field)
					}
					v.query.Inputs = append(v.query.Inputs, builder.Input{
						Name:   "data",
						Fields: fields,
					})
					return v
				}

				type {{ $updateResult }} struct {
					query builder.Query
				}

				func (r {{ $updateResult }}) ExtractQuery() builder.Query {
					return r.query
				}

				func (p {{ $updateResult }}) {{ $model.Name.GoLowerCase }}Model() {}

				func (r {{ $updateResult }}) Exec(ctx context.Context) ({{ $returnType }}, error) {
					var v {{ if $v.List}}count{{ else }}{{ $returnType }}{{ end }}
					if err := r.query.Exec(ctx, &v); err != nil {
						return {{ if $v.List }}-1{{ else }}v{{ end }}, err
					}
					return v{{ if $v.List }}.Count{{ end }}, nil
				}

				{{/* DELETE */}}

				func (r {{ $result }}) Delete() {{ $deleteResult }} {
					var v {{ $deleteResult }}
					v.query = r.query
					v.query.Operation = "mutation"
					v.query.Method = "delete{{ $v.ActualName }}"
					v.query.Model = "{{ $model.Name.String }}"
					v.query.Outputs = {{ $outputName }}Output
					return v
				}

				type {{ $deleteResult }} struct {
					query builder.Query
				}

				func (r {{ $deleteResult }}) ExtractQuery() builder.Query {
					return r.query
				}

				func (p {{ $deleteResult }}) {{ $model.Name.GoLowerCase }}Model() {}

				func (r {{ $deleteResult }}) Exec(ctx context.Context) ({{ $returnType }}, error) {
					var v {{ if $v.List}}count{{ else }}{{ $returnType }}{{ end }}
					if err := r.query.Exec(ctx, &v); err != nil {
						return {{ if $v.List }}-1{{ else }}v{{ end }}, err
					}
					return v{{ if $v.List }}.Count{{ end }}, nil
				}
			{{ end }}
		{{ end }}
	{{ end }}
{{ end }}
